这应该是过采样系列的最后一篇文章，经常有同学在使用FPGA、单片机或者DSP进行过采样时没有正确设计代码，导致结果异常，**有些结果看似正常，而实际却没有意义。**

这篇文章涉及到简单的**整型数据和算术运算**，希望能有所帮助，仅供参考。

举栗子，理想的8 bit ADC，编码范围是0-255，在参考电压是255mV的情况下，**分辨率是1mV**。

对一个理想的9.6mV直流电压进行采样，**ADC无法分辨小数点后的0.6mV**，采样结果会被编码为10，即10mV。

**过采样有效是有前提条件的，在这里是对9.6mV的直流电压加随机噪声。**

**过采样**

对叠加噪声后的信号进行4次采样，理论上应该得到[9.8, 9.6, 10.4, 9.6]4个离散的样本点，而受到ADC分辨率的限制，**实际只能得到[10, 10, 10, 10]4个编码样本，所有样本点都只能分布在。。。8、9、10。。。整数上**。

  

![](https://pic2.zhimg.com/80/v2-61e7afb2d776aac1575b3e4eaa26d10d_720w.jpg)

  

接下来就对这4个样本点详细介绍，直观的感受过采样的原理。

假设信号带宽为B，我们分别分析采样频率F为2B sps/S和8B sps/S两种情况。

当采样频率为2B时，过采样率OSR1=F/(2B)=1;

当采样频率为8B时，过采样率OSR4=F/(2B)=4;

OSR4/OSR1=4，即过采样率提高了4倍（**注意：是提高了4倍**），其分辨率应该会增加1bit。

[过采样系列一：采样定理与过采样率​mp.weixin.qq.com/s?__biz=MzI0ODgxMTg4Mg==&mid=2247485340&idx=3&sn=d3026cf6ae846b053fad22187305876b&chksm=e99a5f99deedd68ff944cb862a2294b785d8c34e402eb3253ad4179cc0318137ff3b92a201cf&scene=21#wechat_redirect![](https://pic2.zhimg.com/v2-06ff1c4395a23125264413c4e0e888fd_180x120.jpg)](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI0ODgxMTg4Mg%3D%3D%26mid%3D2247485340%26idx%3D3%26sn%3Dd3026cf6ae846b053fad22187305876b%26chksm%3De99a5f99deedd68ff944cb862a2294b785d8c34e402eb3253ad4179cc0318137ff3b92a201cf%26scene%3D21%23wechat_redirect)

继续以上面采样9.6mV信号举栗子。

当以采样频率F=1采样时，采集的结果是[10, 10,10, 10]中的任意一个，对应二进制(0000 1010)。

当以采样频率F=4采样时，采集的结果是[10, 10,10, 10]4个序列。

下面对F=4的4个数据进行下抽处理（降采样），可以减少计算量增加分辨率。

  

![](https://pic2.zhimg.com/80/v2-2107dfaed814149673051e949a674eb5_720w.jpg)

**抽取**

ADC是8bit的分辨率，但是在过采样计算时，**不能定义并初始化一个8bit的整形数据**，如果初始化8bit的数据，计算过程会溢出，**最终结果的位宽还是8bit**，并没有增加分辨率，在这里我们定义一个16bit的数据，预留了足够的buffer。

对采样得到的4个8bit数据求和运算，需要计算最大位宽，求和后的最大位宽为8+2=10bit，相当于左移了2bit，变为10bit。

![](https://pic4.zhimg.com/80/v2-37e6a89f8ea9925c1ca243017d2d3dab_720w.jpg)

如果只是简单的求平均，求和后的结果再除以采样个数4的话，则数据其实是右移2bit，又变回原来的8bit位宽，并没有增加分辨率。

在这里我们选择下抽方法是求和后除以2，即右移1bit，则数据从10bit变为9bit，相比于原始的8bit，增加了1bit分辨率（**过采样容易理解，更重要的是下抽**）。

[过采样系列三：量化误差与过采样率​mp.weixin.qq.com/s?__biz=MzI0ODgxMTg4Mg==&mid=2247485508&idx=1&sn=6c0aab028b30e84f98574a1bea5d1487&chksm=e99a5041deedd957b701163cef793cddbb87a3991ab8bb0eb966f657dde0425915eb41c3c739&scene=21#wechat_redirect![](https://pic2.zhimg.com/v2-4013b68648071c8d51bfafa0a3dd15b5_180x120.jpg)](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI0ODgxMTg4Mg%3D%3D%26mid%3D2247485508%26idx%3D1%26sn%3D6c0aab028b30e84f98574a1bea5d1487%26chksm%3De99a5041deedd957b701163cef793cddbb87a3991ab8bb0eb966f657dde0425915eb41c3c739%26scene%3D21%23wechat_redirect)

过采样率为4时，采样的4个数据序列[10, 10,10, 10]求和后是40，对应二进制(00 0010 1000)，右移1bit后变为20，对应二进制(0 0001 0100)

![](https://pic4.zhimg.com/80/v2-c9a46598673ddb97b191d77cd81ea1db_720w.jpg)

255mV参考电压下，原始的8bit ADC，分辨率为1mV，采集的数据是9(0000 1001)，即9mV；

过采样率增加4倍后：

255mV参考电压下，9bit ADC，分辨率为0.5mV，采集的数据是20(0 0001 0100)，即10.0(9.98)mV；

过采样率增加4倍的前提下，只提高了1bit分辨率，效果不是很明显，继续在9.6mV基础上添加随机噪声，**这次过采样率再增加4倍，达到16倍**，即采样速率F=16，对16个采样序列进行计算举例。

![](https://pic2.zhimg.com/80/v2-8f882a2cfacf211835aa5182209723b9_720w.jpg)

对采样得到的16个8bit数据求和运算，最大位宽是8+4=12bit。

求和：10*8+9*7+11=154，对应二进制是(0000 1001 1010)，再右移2bit，则变为10bit的38(00 0010 0110)，（**再次强调，不能简单的求和然后求平均**）。

![](https://pic3.zhimg.com/80/v2-dc472fcbb89ff1c880bca9b204607f86_720w.jpg)

**9.6mV加噪信号：**

**1、255mV参考电压下，原始的8bit ADC，分辨率为1mV，采集的数据是9(0000 1001)，即9mV**

**2、过采率为4后：**

**255mV参考电压下，9bit ADC，分辨率为0.5mV，采集的数据是20(0 0001 0100)，即10.0(9.98)mV；**

**3、过采率为16后：**

**255mV参考电压下，10bit ADC，分辨率为0.25mV，采集的数据是38(00 0010 0110)，即9.47mV；**

从列举的例子可以看出，过采样率是可以提高分辨率的，但是提高采样速率来提高分辨率的代价是巨大的（牛顿第三定律：得到点东西时总要舍弃点什么^_^）。